{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\u00cdndice","text":"<p>Entorno de trabajo</p> <ul> <li>Instalaci\u00f3n de Python y configuraci\u00f3n del entorno.  </li> <li>Uso de Jupyter y Visual Studio Code.  </li> <li>Primer script en Python.</li> </ul> <p>Sintaxis b\u00e1sica y tipos de datos</p> <ul> <li>Variables, constantes y operadores.  </li> <li>Tipos de datos: num\u00e9ricos, booleanos, cadenas.  </li> <li>Conversi\u00f3n de tipos (casting).  </li> <li>Entrada y salida de datos.  </li> </ul> <p>Estructuras de control</p> <ul> <li>Condicionales (if, elif, else).  </li> <li>Bucles (for, while).  </li> <li>Manejo de errores b\u00e1sicos con try/except.  </li> </ul> <p>Ejecuci\u00f3n de un archivo.py</p> <ul> <li>Ejecuci\u00f3n de un archivo</li> <li>Uso de estructuras de control y variables</li> <li>Debug mediante Visual Code</li> </ul> <p>Colecciones de datos</p> <ul> <li>Listas, tuplas, conjuntos y diccionarios.  </li> <li>Operaciones b\u00e1sicas de b\u00fasqueda, inserci\u00f3n y borrado.  </li> <li>Comprensiones de listas (list comprehensions).  </li> </ul> <p>Programas interactivos y debugger</p> <ul> <li>Introducci\u00f3n a las funciones  </li> <li>Ejecutar un programa con parametros</li> <li>Debug mediante Visual Code</li> </ul> <p>Gesti\u00f3n de archivos</p> <ul> <li>Manejo de archivos</li> <li>Lectura, escritura y eliminaci\u00f3n</li> <li>Tipos: texto plano, CSV y JSON</li> </ul> <p>Clases y funciones</p> <ul> <li>Qu\u00e9 es un clase</li> <li>M\u00e9todos de una clase</li> <li>Diferencia entre funciones y m\u00e9todos</li> <li>Llamadas a funciones</li> </ul> <p>Programa con POO</p> <p>!!! tip \"Fuentes y referencias\"     - Python 3.13.7 documentation     - Python CheatSheet     - W3Schools - Tutorial con sandbox</p>"},{"location":"clasesyfunciones/","title":"Clases y funciones en Python","text":""},{"location":"clasesyfunciones/#objetivos","title":"Objetivos","text":"<ul> <li>Entender qu\u00e9 es una clase y para qu\u00e9 se usan en Python.  </li> <li>Definir clases con atributos y m\u00e9todos, incluyendo el m\u00e9todo especial <code>__init__</code>.  </li> <li>Diferenciar entre funciones independientes y m\u00e9todos y usarlos para modularizar el c\u00f3digo.  </li> <li>Comprender c\u00f3mo se definen y se llaman funciones, c\u00f3mo se pasan argumentos y c\u00f3mo se devuelven valores.  </li> <li>Explorar el uso de librer\u00edas est\u00e1ndar (<code>math</code>, <code>random</code> y <code>datetime</code>) dentro de funciones y clases.  </li> </ul>"},{"location":"clasesyfunciones/#1-que-es-una-clase","title":"1. \u00bfQu\u00e9 es una clase?","text":"<p>En Python, una clase es un tipo de objeto que agrupa datos y funcionalidad.  Crear una clase permite definir un nuevo tipo cuyas instancias pueden tener atributos (datos) y m\u00e9todos (funciones) que operan sobre esos datos.  </p> <p>Las clases proporcionan las caracter\u00edsticas b\u00e1sicas de la programaci\u00f3n orientada a objetos, como la encapsulaci\u00f3n y la herencia, y se crean en tiempo de ejecuci\u00f3n .  </p> <p>Cada instancia puede almacenar su estado en atributos y posee m\u00e9todos para modificar ese estado.</p>"},{"location":"clasesyfunciones/#ventajas","title":"Ventajas","text":"<ul> <li>Modelan entidades del mundo real (C\u00edrculo, Alumno, Reloj) con propiedades y operaciones.  </li> <li>Facilitan la reutilizaci\u00f3n y organizaci\u00f3n del c\u00f3digo.  </li> <li>Soportan herencia y polimorfismo </li> </ul>"},{"location":"clasesyfunciones/#2-definicion-de-clases-y-el-metodo-__init__","title":"2. Definici\u00f3n de clases y el m\u00e9todo <code>__init__</code>","text":"<p>Una clase se define con la palabra clave <code>class</code>:</p> <pre><code>class NombreDeLaClase:\n    # bloque de declaraciones (m\u00e9todos, variables de clase)\n    pass\n</code></pre> <p>Cuando Python ejecuta la definici\u00f3n de la clase, crea un nuevo espacio de nombres y genera un objeto clase que lo envuelve</p>"},{"location":"clasesyfunciones/#el-metodo-__init__","title":"El m\u00e9todo <code>__init__</code>","text":"<p>Para inicializar los atributos de cada instancia se usa el m\u00e9todo especial <code>__init__()</code>.  </p> <pre><code>class Punto2D:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def mover(self, dx, dy):\n        self.x += dx\n        self.y += dy\n</code></pre> <p>Ejemplo de uso:</p> <pre><code>p = Punto2D(3, 4)\n# Se ejecuta autom\u00e1ticamente p.__init__(3, 4)\n</code></pre>"},{"location":"clasesyfunciones/#3-metodos-de-instancia-y-uso-de-self","title":"3. M\u00e9todos de instancia y uso de <code>self</code>","text":"<p>Los m\u00e9todos son funciones definidas dentro de una clase que operan sobre sus instancias. El primer par\u00e1metro se llama habitualmente <code>self</code>.  </p> <pre><code>class Circulo:\n    def __init__(self, radio):\n        self.radio = radio\n\n    def area(self):\n        return 3.14159 * self.radio ** 2\n\nc = Circulo(5)\nprint(c.area())\n</code></pre> <p>Una llamada <code>obj.metodo(arg1, arg2)</code> equivale a <code>Clase.metodo(obj, arg1, arg2)</code> .  </p> <p>Los atributos pueden a\u00f1adirse o eliminarse din\u00e1micamente con <code>del</code>.</p>"},{"location":"clasesyfunciones/#4-funciones-y-modularidad","title":"4. Funciones y modularidad","text":"<p>Aunque las clases agrupan datos y m\u00e9todos, las funciones independientes siguen siendo una herramienta b\u00e1sica para modularizar un programa. Se definen con la palabra clave def y se pueden llamar desde cualquier parte del c\u00f3digo. Por ejemplo, para imprimir la serie de Fibonacci hasta un l\u00edmite n:</p> <pre><code>def fib(n):\n    \\\"\\\"\\\"Imprime la serie de Fibonacci menor que n\\\"\\\"\\\"\n    a, b = 0, 1\n    while a &lt; n:\n        print(a, end=' ')\n        a, b = b, a + b\n    print()\n\nfib(2000)\n</code></pre> <p>El encabezado def debe ir seguido del nombre de la funci\u00f3n y una lista de par\u00e1metros entre par\u00e9ntesis. El cuerpo de la funci\u00f3n se escribe indentado. La primera cadena del cuerpo puede ser una docstring, una cadena que documenta la funci\u00f3n. Cuando se ejecuta una funci\u00f3n:</p> <p>Python crea una tabla de s\u00edmbolos local para las variables y argumentos. La asignaci\u00f3n de variables dentro de la funci\u00f3n afecta a esta tabla local.</p> <p>Los argumentos que se pasan al llamar a la funci\u00f3n se introducen en la tabla local; el paso de argumentos se realiza por valor, pero ese valor es una referencia al objeto (lo que implica que se pueden modificar objetos mutables).</p> <p>Si no se incluye ninguna instrucci\u00f3n return, la funci\u00f3n devuelve el valor especial None. Para devolver un valor concreto se utiliza return expresi\u00f3n. Por ejemplo, la funci\u00f3n fib2 devuelve la lista con los n\u00fameros de Fibonacci menores que n.</p> <p>Las funciones se comportan como objetos de primera clase: se pueden asignar a variables, pasar como argumento a otras funciones o devolverlas como resultado. Esto permite construir c\u00f3digo flexible y modular.</p>"},{"location":"clasesyfunciones/#5-uso-de-librerias-estandar-en-funciones-y-clases","title":"5. Uso de librer\u00edas est\u00e1ndar en funciones y clases","text":""},{"location":"clasesyfunciones/#51-modulo-math","title":"5.1 M\u00f3dulo <code>math</code>","text":"<p>Ofrece funciones matem\u00e1ticas como:  </p> <ul> <li><code>math.sqrt(x)</code> </li> <li><code>math.factorial(n)</code> </li> <li><code>math.sin(x), math.cos(x), math.tan(x)</code> </li> </ul> <p>Se importa con:</p> <pre><code>import math\n</code></pre>"},{"location":"clasesyfunciones/#52-modulo-random","title":"5.2 M\u00f3dulo <code>random</code>","text":"<p>Genera n\u00fameros pseudoaleatorios.  </p> <p>Funciones \u00fatiles:  </p> <ul> <li><code>random.random()</code> \u2192 flotante en <code>[0.0, 1.0)</code> </li> <li><code>random.randint(a, b)</code> \u2192 entero en <code>[a, b]</code> </li> <li><code>random.choice(seq)</code> \u2192 selecciona un elemento  </li> </ul> <p>Se puede inicializar con <code>random.seed(valor)</code>.  </p>"},{"location":"clasesyfunciones/#53-modulo-datetime","title":"5.3 M\u00f3dulo <code>datetime</code>","text":"<p>Permite manejar fechas y horas. Ejemplos:</p> <ul> <li><code>datetime.datetime.now()</code> </li> <li><code>datetime.date(2025, 5, 2)</code> </li> <li><code>datetime1 - datetime2</code> \u2192 <code>timedelta</code> </li> </ul> <p>Se importa con:</p> <pre><code>import datetime\n</code></pre>"},{"location":"clasesyfunciones/#6-ejemplos-integrados","title":"6. Ejemplos integrados","text":""},{"location":"clasesyfunciones/#ejemplo-1-calculadora-geometrica","title":"Ejemplo 1: Calculadora geom\u00e9trica","text":"<pre><code>import math\n\nclass Circulo:\n    def __init__(self, radio):\n        self.radio = radio\n\n    def area(self):\n        return math.pi * (self.radio ** 2)\n\n    def circunferencia(self):\n        return 2 * math.pi * self.radio\n\ndef mostrar_info_circulo(radio):\n    c = Circulo(radio)\n    print(f\"Radio: {radio}\")\n    print(f\"\u00c1rea: {c.area():.2f}\")\n    print(f\"Circunferencia: {c.circunferencia():.2f}\")\n\nmostrar_info_circulo(3)\n</code></pre>"},{"location":"clasesyfunciones/#ejemplo-2-juego-de-dados","title":"Ejemplo 2: Juego de dados","text":"<pre><code>import random\n\nclass JuegoDado:\n    def __init__(self, caras=6):\n        self.caras = caras\n\n    def lanzar(self):\n        return random.randint(1, self.caras)\n\ndef jugar(dado, tiradas=5):\n    print(f\"Lanzando un dado de {dado.caras} caras {tiradas} veces:\")\n    for i in range(tiradas):\n        print(f\"Tirada {i+1}: {dado.lanzar()}\")\n\ndado6 = JuegoDado()\njugar(dado6)\n</code></pre>"},{"location":"clasesyfunciones/#ejemplo-3-temporizador-con-datetime","title":"Ejemplo 3: Temporizador con <code>datetime</code>","text":"<pre><code>import datetime\n\nclass Temporizador:\n    def __init__(self):\n        self.inicio = datetime.datetime.now()\n\n    def tiempo_transcurrido(self):\n        return datetime.datetime.now() - self.inicio\n\ndef probar_temporizador():\n    t = Temporizador()\n    suma = sum(range(1_000_000))\n    duracion = t.tiempo_transcurrido()\n    print(f\"Tiempo transcurrido: {duracion.total_seconds():.4f} segundos\")\n\nprobar_temporizador()\n</code></pre>"},{"location":"clasesyfunciones/#7-resumen-y-recomendaciones","title":"7. Resumen y recomendaciones","text":"<ul> <li>Las clases permiten agrupar datos y operaciones \u2192 base de la POO.  </li> <li>Los m\u00e9todos operan sobre el estado interno de los objetos; <code>__init__</code> inicializa atributos; <code>self</code> da acceso a miembros.  </li> <li>Las funciones permiten modularizar y reutilizar c\u00f3digo \u2192 crean \u00e1mbito local, aceptan par\u00e1metros, devuelven valores con <code>return</code>.  </li> <li>La biblioteca est\u00e1ndar ofrece m\u00f3dulos potentes:  </li> <li><code>math</code> para c\u00e1lculos matem\u00e1ticos.  </li> <li><code>random</code> para generar n\u00fameros aleatorios.  </li> <li><code>datetime</code> para trabajar con fechas y horas.  </li> </ul> <p>Integrar funciones, clases y librer\u00edas est\u00e1ndar permite escribir programas claros, reutilizables y robustos.  </p>"},{"location":"coleccionesDatos/","title":"Unidad: Colecciones de Datos en Python","text":""},{"location":"coleccionesDatos/#objetivos-de-la-unidad","title":"Objetivos de la unidad","text":"<ul> <li>Conocer y manipular listas, tuplas, conjuntos y diccionarios.  </li> <li>Usar operaciones b\u00e1sicas de inserci\u00f3n, b\u00fasqueda y borrado.  </li> <li>Crear listas din\u00e1micas con list comprehensions.  </li> </ul>"},{"location":"coleccionesDatos/#contenidos","title":"Contenidos","text":""},{"location":"coleccionesDatos/#1-listas","title":"1. Listas","text":"<p>Las listas (<code>list</code>) son secuencias mutables que permiten almacenar cualquier tipo de dato y cuyo tama\u00f1o puede crecer o disminuir din\u00e1micamente. Los \u00edndices comienzan en <code>0</code> y se admiten \u00edndices negativos para contar desde el final (<code>-1</code> es el \u00faltimo elemento). Adem\u00e1s de acceder a un elemento concreto, el slicing (<code>lista[inicio:fin:paso]</code>) permite extraer sublistas sin bucles expl\u00edcitos.</p> <p>Operaciones principales</p> <ul> <li>A\u00f1adir elementos: <code>append(x)</code> agrega <code>x</code> al final; <code>extend(iterable)</code> concatena otra colecci\u00f3n; <code>insert(i, x)</code> inserta <code>x</code> antes del \u00edndice <code>i</code>.  </li> <li>Eliminar elementos: <code>remove(x)</code> borra la primera ocurrencia de <code>x</code> y lanza un error si no existe; <code>pop([i])</code> extrae y devuelve el elemento de la posici\u00f3n <code>i</code> (por defecto, el \u00faltimo); <code>clear()</code> vac\u00eda la lista.  </li> <li>Reordenar: <code>sort()</code> ordena la lista en su lugar (acepta argumentos <code>key</code> y <code>reverse</code>), mientras que <code>sorted(lista)</code> devuelve una nueva lista ordenada. <code>reverse()</code> invierte el orden de los elementos.  </li> <li>Buscar y contar: <code>index(x)</code> devuelve la posici\u00f3n de la primera aparici\u00f3n de <code>x</code>; <code>count(x)</code> devuelve cu\u00e1ntas veces aparece <code>x</code>.  </li> <li>Copiar: <code>lista.copy()</code> o <code>lista[:]</code> devuelve una copia superficial.</li> <li>Rebanado (slicing): lista[inicio:fin:paso] devuelve una sublista. Se pueden omitir inicio o fin, usar \u00edndices negativos para contar desde el final y especificar un paso distinto de 1 para saltar elementos o invertir el orden.</li> </ul> <pre><code>\nflowchart TD\n  subgraph L[\"Lista (list)\"]\n    direction TB\n    L1[\"Estructura&lt;br/&gt;[a, b, c] \u00b7 lst[i] \u00b7 lst[i:j:k]\"]\n    L2[\"Caracter\u00edsticas&lt;br/&gt;Mutable \u00b7 Ordenada \u00b7 Indexada \u00b7 Duplicados OK \u00b7 Heterog\u00e9nea\"]\n    L3[\"Operaciones&lt;br/&gt;append \u00b7 extend \u00b7 insert \u00b7 pop/remove/clear \u00b7 sort/sorted \u00b7 in/index/count \u00b7 [f(x) for x in lst]\"]\n    L4[\"Cu\u00e1ndo usar&lt;br/&gt;Secuencias mutables \u00b7 pilas/colas \u00b7 acumulaci\u00f3n/transformaci\u00f3n\"]\n    L1 --&gt; L2 --&gt; L3 --&gt; L4\nend\n</code></pre> <p>Ejemplo</p> <pre><code># Crear y modificar una lista\nnumeros = [10, 5, 7, 3, 8]\nnumeros.append(2)          # [10, 5, 7, 3, 8, 2]\nnumeros.insert(2, 9)       # [10, 5, 9, 7, 3, 8, 2]\nultimo = numeros.pop()     # extrae 2, lista = [10, 5, 9, 7, 3, 8]\nnumeros.remove(7)          # [10, 5, 9, 3, 8]\n\n# Ordenar\nordenados = sorted(numeros)    # [3, 5, 8, 9, 10] (copia ordenada)\nnumeros.sort(reverse=True)     # lista original ahora es [10, 9, 8, 5, 3]\nprint(numeros, ordenados)\n`\n# Slicing\nprimeros_tres = numeros[:3]        # [10, 9, 8]\nultimos_dos = numeros[-2:]         # [5, 3]\nsaltos_de_dos = numeros[::2]       # [10, 8, 3]\ninvertida = numeros[::-1]          # [3, 5, 8, 9, 10]\n\nsublista = numeros[1:4]            # [9, 8, 5]\n\nprint(numeros)\nprint(\"Ordenados:\", ordenados)\nprint(\"Primeros tres:\", primeros_tres)\nprint(\"\u00daltimos dos:\", ultimos_dos)\nprint(\"Saltos de dos:\", saltos_de_dos)\nprint(\"Invertida:\", invertida)\nprint(\"Sublista [1:4]:\", sublista)\n</code></pre>"},{"location":"coleccionesDatos/#2-tuplas","title":"2. Tuplas","text":"<p>Las tuplas (tuple) son secuencias inmutables: una vez creadas, no se pueden a\u00f1adir ni eliminar elementos. Son \u00fatiles para agrupar datos heterog\u00e9neos que no deben cambiar (coordenadas, fechas, etc.) y pueden utilizarse como claves en diccionarios al ser objetos hashables.</p> <p>Python permite desempaquetar una tupla en m\u00faltiples variables y convertirla a lista si se necesita modificarla.</p> <pre><code>flowchart TD\n\n  subgraph T[\"Tupla (tuple)\"]\n    direction TB\n    T1[\"Estructura&lt;br/&gt;(a, b, c) \u00b7 a, b = t\"]\n    T2[\"Caracter\u00edsticas&lt;br/&gt;Inmutable \u00b7 Ordenada \u00b7 Indexada \u00b7 Duplicados OK \u00b7 Hashable si sus elementos lo son\"]\n    T3[\"Operaciones&lt;br/&gt;t[i] \u00b7 slicing \u00b7 count \u00b7 index \u00b7 t1 + t2 \u00b7 uso como clave\"]\n    T4[\"Cu\u00e1ndo usar&lt;br/&gt;Datos constantes \u00b7 claves compuestas \u00b7 seguridad frente a cambios\"]\n    T1 --&gt; T2 --&gt; T3 --&gt; T4\n  end\n</code></pre> <pre><code>punto = (4, 5)\nx, y = punto      # desempaquetado\n\n# Tuplas como claves\ncoordenadas = {(0, 0): \"origen\", (1, 2): \"punto A\"}\nprint(coordenadas[(1, 2)])  # \"punto A\"\n\n# Conversi\u00f3n para modificar\nlista_punto = list(punto)\nlista_punto[0] = 10\npunto_modificado = tuple(lista_punto)  # (10, 5)\n\n</code></pre> <p>\ud83d\udd39 Inmutables \u2192 no se pueden modificar tras crearlas.</p>"},{"location":"coleccionesDatos/#3-conjuntos-set","title":"3. Conjuntos (set)","text":"<p>Un conjunto (set) es una colecci\u00f3n no ordenada y sin elementos duplicados. Se utiliza para eliminar duplicados, comprobar pertenencia r\u00e1pidamente y realizar operaciones de teor\u00eda de conjuntos. Para crear un conjunto vac\u00edo se usa set(), ya que {} crea un diccionario.</p> <p>Operaciones principales</p> <ul> <li> <p>Agregar o quitar: add(x) inserta x; remove(x) elimina x y lanza error si no existe; discard(x) elimina x si existe; pop() extrae un elemento arbitrario; clear() vac\u00eda el conjunto.</p> </li> <li> <p>Uni\u00f3n (| o union()): combina elementos de ambos conjuntos.</p> </li> <li> <p>Intersecci\u00f3n (&amp; o intersection()): elementos comunes a ambos conjuntos.</p> </li> <li> <p>Diferencia (- o difference()): elementos presentes en un conjunto pero no en otro.</p> </li> <li> <p>Diferencia sim\u00e9trica (^ o symmetric_difference()): elementos en uno u otro pero no en ambos.</p> </li> </ul> <pre><code>flowchart TD\n\n  subgraph S[\"Conjunto (set/frozenset)\"]\n    direction TB\n    S1[\"Estructura&lt;br/&gt;{a, b, c} \u00b7 set() \u00b7 x in s\"]\n    S2[\"Caracter\u00edsticas&lt;br/&gt;(set) mutable \u00b7 (frozenset) inmutable \u00b7 Sin orden \u00b7 Sin \u00edndices \u00b7 Sin duplicados \u00b7 Elementos hashables\"]\n    S3[\"Operaciones&lt;br/&gt;Uni\u00f3n | \u00b7 Intersecci\u00f3n &amp; \u00b7 Diferencia - \u00b7 Sim\u00e9trica ^ \u00b7 add/update/remove/discard/pop/clear \u00b7 issubset/issuperset/isdisjoint\"]\n    S4[\"Cu\u00e1ndo usar&lt;br/&gt;Eliminar duplicados \u00b7 pruebas de pertenencia \u00b7 \u00e1lgebra de conjuntos en datos\"]\n    S1 --&gt; S2 --&gt; S3 --&gt; S4\n  end\n</code></pre> <pre><code># Crear conjuntos y operaciones\na = {1, 2, 3, 3}\nb = set([3, 4, 5])\n\nprint(a)          # {1, 2, 3}\nprint(a | b)      # uni\u00f3n =&gt; {1, 2, 3, 4, 5}\nprint(a &amp; b)      # intersecci\u00f3n =&gt; {3}\nprint(a - b)      # diferencia =&gt; {1, 2}\nprint(a ^ b)      # diferencia sim\u00e9trica =&gt; {1, 2, 4, 5}\n\n# Comprensi\u00f3n de conjuntos\nconsonantes = {c for c in 'programacion' if c not in 'aeiou'}\nprint(consonantes)\n</code></pre> <p>\ud83d\udd39 No admiten elementos duplicados.</p>"},{"location":"coleccionesDatos/#4-diccionarios","title":"4. Diccionarios","text":"<p>Un diccionario (dict) almacena pares clave\u2011valor. Las claves deben ser \u00fanicas e inmutables y se accede a los valores mediante la clave. Los diccionarios son ideales para asociar informaci\u00f3n y se utilizan frecuentemente en Python (equivalen a los maps en Java o a los arrays asociativos de PHP).</p> <p>Operaciones principales</p> <ul> <li> <p>Crear y modificar: se define con llaves y pares clave: valor. Se a\u00f1ade o actualiza con dict[clave] = valor.</p> </li> <li> <p>Eliminar: del dict[clave] elimina el par; pop(clave) extrae y devuelve el valor; clear() borra todo el diccionario.</p> </li> <li> <p>Recorrer: keys() devuelve las claves; values() devuelve los valores; items() devuelve tuplas (clave, valor) para iterar.</p> </li> <li> <p>Obtener valor seguro: get(clave, predeterminado) evita errores cuando la clave no existe.</p> </li> <li> <p>Ordenar: sorted(diccionario) devuelve una lista de claves ordenadas.</p> </li> <li> <p>Comprensiones de diccionario: permiten construir diccionarios de forma concisa.</p> </li> </ul> <pre><code>flowchart TD\n\n  subgraph D[\"Diccionario (dict)\"]\n    direction TB\n    D1[\"Estructura&lt;br/&gt;{k: v} \u00b7 d[k] \u00b7 d.get(k, def) \u00b7 keys/values/items\"]\n    D2[\"Caracter\u00edsticas&lt;br/&gt;Mutable \u00b7 Orden de inserci\u00f3n al iterar (3.7+) \u00b7 Claves \u00fanicas \u00b7 Claves hashables \u00b7 Valores de cualquier tipo\"]\n    D3[\"Operaciones&lt;br/&gt;d[k]=v \u00b7 update \u00b7 pop/popitem/del/clear \u00b7 {k:v for ...} \u00b7 {**d1, **d2} \u00b7 setdefault\"]\n    D4[\"Cu\u00e1ndo usar&lt;br/&gt;Mapeos/\u00edndices sem\u00e1nticos \u00b7 contadores/configuraci\u00f3n \u00b7 interoperar con JSON\"]\n    D1 --&gt; D2 --&gt; D3 --&gt; D4\n  end\n</code></pre> <pre><code># Crear un diccionario\npersona = {\"nombre\": \"Ana\", \"edad\": 25, \"ciudad\": \"Barcelona\"}\npersona[\"edad\"] = 26        # actualiza valor\npersona[\"profesion\"] = \"Ingeniera\"  # a\u00f1ade nuevo par\n\nprint(persona.get(\"correo\", \"sin correo\"))  # evita KeyError\n\n# Eliminar\ndel persona[\"ciudad\"]\nedad = persona.pop(\"edad\")\n\n# Recorrer claves y valores\nfor clave, valor in persona.items():\n    print(clave, \"-&gt;\", valor)\n\n# Comprensi\u00f3n de diccionarios\ncuadrados = {x: x**2 for x in range(1, 6)}  # {1:1, 2:4, 3:9, 4:16, 5:25}\n</code></pre>"},{"location":"coleccionesDatos/#5-comprensiones","title":"5. Comprensiones","text":"<p>Las comprensiones permiten construir colecciones de manera compacta y legible.</p> <ul> <li> <p>List comprehensions: [expr for elem in iterable if condicion]. Permiten filtrar y transformar elementos.</p> </li> <li> <p>Set comprehensions: {expr for elem in iterable} construyen un conjunto.</p> </li> <li> <p>Dict comprehensions: {clave_expr: valor_expr for elem in iterable} construyen un diccionario.</p> </li> </ul> <pre><code># Lista con los cuadrados de los n\u00fameros impares del 0 al 10\nimpares_cuadrados = [x**2 for x in range(11) if x % 2 != 0]\n\n# Conjunto de vocales \u00fanicas en una frase\nfrase = \"Esto es un ejemplo\"\nvocales = {c.lower() for c in frase if c.lower() in 'aeiou'}\n\n# Diccionario que mapea n\u00fameros pares a su cubo si el cubo &gt; 20\ncubos = {x: x**3 for x in range(6) if x % 2 == 0 and x**3 &gt; 20}\n\nprint(impares_cuadrados)\nprint(vocales)\nprint(cubos)\n\n</code></pre>"},{"location":"coleccionesDatos/#comparativa-de-colecciones","title":"Comparativa de colecciones","text":"<p>Tabla comparativa con los usos m\u00e1s comunes de las colecciones en Python (<code>list</code>, <code>tuple</code>, <code>set</code>, <code>dict</code>) y cu\u00e1ndo conviene utilizarlas:  </p> Colecci\u00f3n Sintaxis Caracter\u00edsticas Cu\u00e1ndo usar Lista (<code>list</code>) <code>[1, 2, 3]</code> - Ordenada  - Mutable (se pueden a\u00f1adir, modificar y eliminar elementos) - Permite duplicados \u2022 Guardar datos en orden. \u2022 Acceder por posici\u00f3n/\u00edndice. \u2022 A\u00f1adir o quitar elementos frecuentemente. \u2022 Permitir duplicados. Tupla (<code>tuple</code>) <code>(1, 2, 3)</code> - Ordenada  - Inmutable (no se puede modificar despu\u00e9s de creada) - Permite duplicados \u2022 Datos que no deben cambiar (constantes, coordenadas, configuraciones). \u2022 Usar como clave en un diccionario o elemento en un conjunto. \u2022 Mejor rendimiento (m\u00e1s r\u00e1pida y ligera que lista). Conjunto (<code>set</code>) <code>{1, 2, 3}</code> - No ordenado  - Mutable (se pueden a\u00f1adir y eliminar elementos) - No permite duplicados \u2022 Eliminar duplicados autom\u00e1ticamente. \u2022 Operaciones de conjuntos (uni\u00f3n, intersecci\u00f3n, diferencia). \u2022 Comprobar existencia r\u00e1pida (<code>in</code>). Diccionario (<code>dict</code>) <code>{\"clave\": \"valor\"}</code> - Colecci\u00f3n de pares clave:valor - Claves \u00fanicas (los valores pueden repetirse) - Acceso muy r\u00e1pido por clave \u2022 Asociar un valor a una clave (como un \u201c\u00edndice nombrado\u201d). \u2022 Almacenar datos tipo JSON o registros. \u2022 B\u00fasquedas r\u00e1pidas por clave en lugar de \u00edndice. <p>\ud83d\udc49 Regla r\u00e1pida para elegir: - Lista \u2192 orden y cambios frecuentes. - Tupla \u2192 orden pero sin cambios. - Set \u2192 sin orden, sin duplicados, operaciones de teor\u00eda de conjuntos. - Dict \u2192 pares clave-valor con acceso r\u00e1pido.  </p>"},{"location":"coleccionesDatos/#diagrama-de-decision","title":"Diagrama de decisi\u00f3n","text":"<pre><code>flowchart TD\n    A[\"\u00bfNecesitas pares clave-valor?\"] --&gt;|S\u00ed| D[\"Usa Diccionario (dict)\"]\n    A --&gt;|No| B[\"\u00bfNecesitas mantener el orden?\"]\n\n    B --&gt;|S\u00ed| C[\"\u00bfLos datos deben ser inmutables?\"]\n    B --&gt;|No| E[\"\u00bfNecesitas evitar duplicados?\"]\n\n    C --&gt;|S\u00ed| F[\"Usa Tupla (tuple)\"]\n    C --&gt;|No| G[\"Usa Lista (list)\"]\n\n    E --&gt;|S\u00ed| H[\"Usa Conjunto (set)\"]\n    E --&gt;|No| G\n</code></pre>"},{"location":"datosOperadores/","title":"Tipos de Datos y Operadores","text":""},{"location":"datosOperadores/#objetivos","title":"Objetivos","text":"<ul> <li>Conocer los tipos de datos b\u00e1sicos en Python: num\u00e9ricos, booleanos y cadenas.  </li> <li>Aprender el uso de operadores aritm\u00e9ticos, de comparaci\u00f3n, l\u00f3gicos y especiales.  </li> <li>Realizar conversiones entre tipos de datos (casting).  </li> <li>Aplicar la entrada y salida de datos con <code>input()</code> y <code>print()</code>.  </li> </ul>"},{"location":"datosOperadores/#contenidos","title":"Contenidos","text":""},{"location":"datosOperadores/#1-tipos-de-datos-basicos","title":"1. Tipos de datos b\u00e1sicos","text":"<p>Python es un lenguaje de tipado din\u00e1mico: no hace falta declarar el tipo de la variable, se asigna autom\u00e1ticamente seg\u00fan el valor.  </p> <p>!!! La funci\u00f3n type() En Python, todo dato es un objeto de una determinada clase (entero, decimal, texto, etc.). La funci\u00f3n integrada type() permite saber de qu\u00e9 tipo es una variable o un valor.</p>"},{"location":"datosOperadores/#ejemplos","title":"Ejemplos","text":"<pre><code>\n# Enteros\na = 42\nprint(type(a))  # &lt;class 'int'&gt;\n\n# Flotantes\nb = 3.14\nprint(type(b))  # &lt;class 'float'&gt;\n\n# Booleanos\nc = True\nprint(type(c))  # &lt;class 'bool'&gt;\n\n# Cadenas\nd = \"Hola, mundo\"\nprint(type(d))  # &lt;class 'str'&gt;\n</code></pre>"},{"location":"datosOperadores/#2-operadores-aritmeticos","title":"2. Operadores aritm\u00e9ticos","text":"<pre><code>    + suma\n\n    - resta\n\n    * multiplicaci\u00f3n\n\n    / divisi\u00f3n (flotante)\n\n    // divisi\u00f3n entera\n\n    % m\u00f3dulo (resto)\n\n    ** potencia\n</code></pre>"},{"location":"datosOperadores/#ejemplos_1","title":"Ejemplos","text":"<pre><code>\n\nx, y = 10, 3\nprint(x + y)   # 13\nprint(x - y)   # 7\nprint(x * y)   # 30\nprint(x / y)   # 3.333...\nprint(x // y)  # 3\nprint(x % y)   # 1\nprint(x ** y)  # 1000\n</code></pre>"},{"location":"datosOperadores/#3-operadores-de-comparacion","title":"3. Operadores de comparaci\u00f3n","text":"<p>Devuelven valores booleanos (True o False).</p> <pre><code>== igual\n!= distinto\n&lt;, &lt;=, &gt;, &gt;=\n</code></pre>"},{"location":"datosOperadores/#ejemplo","title":"Ejemplo","text":"<pre><code>\nprint(5 == 5)   # True\nprint(5 != 3)   # True\nprint(5 &lt; 10)   # True\nprint(10 &gt;= 15) # False\n</code></pre>"},{"location":"datosOperadores/#4-operadores-logicos","title":"4. Operadores l\u00f3gicos","text":"<p>``` and \u2192 Verdadero si ambas expresiones lo son.</p> <pre><code>or \u2192 Verdadero si al menos una lo es.\n\nnot \u2192 Niega el valor.\n</code></pre> <pre><code>\n#### Ejemplo\n\n```python\nx, y = True, False\nprint(x and y)  # False\nprint(x or y)   # True\nprint(not x)    # False\n</code></pre>"},{"location":"datosOperadores/#5-operadores-especiales","title":"5. Operadores especiales","text":"<pre><code>    Identidad: is, is not \u2192 comparan si dos variables apuntan al mismo objeto en memoria.\n\n    Pertenencia: in, not in \u2192 verifican si un valor est\u00e1 dentro de una colecci\u00f3n.\n</code></pre> <p>**El tipo list (listas). Se incluye aqu\u00ed para ejemplificar el uso del operador.     Una lista es una colecci\u00f3n ordenada y modificable de elementos. Se escriben entre corchetes [], separados por comas.     Permiten almacenar varios valores en una sola variable.</p>"},{"location":"datosOperadores/#ejemplo_1","title":"Ejemplo","text":"<pre><code>a = [1, 2, 3]\nb = a\nc = [1, 2, 3]\n\nprint(a is b)   # True (misma referencia en memoria)\nprint(a is c)   # False (contenido igual pero distinto objeto)\nprint(2 in a)   # True\nprint(5 not in a) # True\n</code></pre>"},{"location":"datosOperadores/#6-conversion-de-tipos-casting","title":"6. Conversi\u00f3n de tipos (Casting)","text":"<p>Se usa para cambiar el tipo de una variable.</p> <p>De cadena a n\u00famero</p> <pre><code>    x = int(\"10\")\n    print(x + 5)  # 15\n</code></pre> <p>De n\u00famero a cadena</p> <pre><code>y = str(3.14)\nprint(\"El n\u00famero es \" + y)\n</code></pre> <p>De flotante a entero</p> <pre><code>    z = int(3.99)\n    print(z)  # 3\n</code></pre>"},{"location":"datosOperadores/#7-entrada-y-salida-de-datos","title":"7. Entrada y salida de datos","text":"<p>input() \u2192 lee datos como texto.</p> <p>print() \u2192 muestra resultados en pantalla.</p> <pre><code>    nombre = input(\"\u00bfC\u00f3mo te llamas? \")\n    edad = int(input(\"\u00bfCu\u00e1ntos a\u00f1os tienes? \"))\n    print(\"Hola\", nombre, \"tienes\", edad, \"a\u00f1os.\")\n</code></pre>"},{"location":"estructurasControl/","title":"Estructuras de Control","text":""},{"location":"estructurasControl/#objetivos","title":"Objetivos","text":"<ul> <li> <p>Dominar las instrucciones condicionales y comprender que Python basa su sintaxis en la sangr\u00eda, no en llaves ni par\u00e9ntesis.</p> </li> <li> <p>Repetir tareas con bucles for y while, incluyendo t\u00e9cnicas de iteraci\u00f3n como range(), enumerate() y zip(), y comprender c\u00f3mo interrumpir o continuar la ejecuci\u00f3n.</p> </li> <li> <p>Gestionar el flujo de ejecuci\u00f3n cuando ocurren errores mediante bloques try/except/else/finally y aprender a lanzar excepciones propias.</p> </li> <li> <p>Conocer nuevas construcciones de control como la expresi\u00f3n condicional en l\u00ednea y la sentencia match introducida en Python\u00a03.10.</p> </li> </ul>"},{"location":"estructurasControl/#1-condicionales","title":"1. Condicionales","text":"<p>Las sentencias condicionales permiten ejecutar bloques de c\u00f3digo s\u00f3lo si se cumple una condici\u00f3n. En Python no se utilizan par\u00e9ntesis ni llaves como en Java o PHP; la sintaxis se basa en la palabra clave (if, elif, else), seguida de dos puntos (:) y un bloque indentado.</p> <ul> <li>if \u2192 Eval\u00faa una condici\u00f3n. Si es verdadera, ejecuta el bloque de c\u00f3digo que contiene.</li> <li>elif (else if) \u2192 Permite comprobar una condici\u00f3n adicional si la primera no se cumple. Se pueden encadenar varios elif.</li> <li>else \u2192 Se ejecuta solo si ninguna de las condiciones anteriores (if o elif) se cumple.</li> <li>: \u2192 Marca el inicio del bloque de c\u00f3digo que depende de la condici\u00f3n.</li> </ul> <p>Indentaci\u00f3n (tabulaci\u00f3n) \u2192 En Python es obligatoria; indica qu\u00e9 instrucciones pertenecen al bloque.</p> <pre><code>flowchart TD\n    A([Inicio]) --&gt; C1{\u00bfcondici\u00f3n 1?}\n    C1 -- S\u00ed --&gt; B1[Bloque if]\n    C1 -- No --&gt; C2{\u00bfcondici\u00f3n 2?}\n    C2 -- S\u00ed --&gt; B2[Bloque elif]\n    C2 -- No --&gt; BE[ Bloque else ]\n    B1 --&gt; Z([Fin])\n    B2 --&gt; Z\n    BE --&gt; Z\n    %% Estructura if / elif / else\n\n</code></pre> <pre><code>edad = 18\n\nif edad &lt; 12:\n    print(\"Eres un ni\u00f1o\")\nelif edad &lt; 18:\n    print(\"Eres adolescente\")\nelif edad &lt; 65:\n    print(\"Eres adulto\")\nelse:\n    print(\"Eres mayor\")\n\n</code></pre> <p>Expresi\u00f3n condicional (operador ternario)</p> <p>Python dispone de una expresi\u00f3n condicional para asignar valores seg\u00fan una condici\u00f3n. Su forma es valor_si_verdadero if condicion else valor_si_falso. Permite escribir decisiones simples en una sola l\u00ednea y equivale al operador ternario condici\u00f3n ? a : b de otros lenguajes.</p> <pre><code>flowchart TD\n    A([Inicio]) --&gt; C{\u00bfcondici\u00f3n?}\n    C -- S\u00ed --&gt; T[valor_si_verdadero]\n    C -- No --&gt; F[valor_si_falso]\n    T --&gt; AS[Asignar a variable]\n    F --&gt; AS\n    AS --&gt; Z([Fin])\n    %% Expresi\u00f3n condicional: v = a if cond else b\n</code></pre> <pre><code>mensaje = \"par\" if numero % 2 == 0 else \"impar\"\n</code></pre> <p>La sentencia match</p> <p>Desde Python\u00a03.10 existe la sentencia match para comparar un valor contra varios patrones, similar al switch pero m\u00e1s potente. Solo se ejecuta el primer patr\u00f3n que coincide se puede usar _ como comod\u00edn y agrupar varios valores con |</p> <pre><code>flowchart TD\n    A([Inicio]) --&gt; M[match estado]\n    M --&gt; C400{==400}\n    C400 -- Si --&gt; R400[Peticion incorrecta]\n    C400 -- No --&gt; C404{==404}\n    C404 -- Si --&gt; R404[No encontrado]\n    C404 -- No --&gt; C418{==418}\n    C418 -- Si --&gt; R418[Soy una tetera]\n    C418 -- No --&gt; DEF[_ -&gt; Error desconocido]\n    R400 --&gt; Z([Fin])\n    R404 --&gt; Z\n    R418 --&gt; Z\n    DEF --&gt; Z\n</code></pre> <pre><code>def http_error(status):\n    match status:\n        case 400:\n            return \"Petici\u00f3n incorrecta\"\n        case 404:\n            return \"No encontrado\"\n        case 418:\n            return \"Soy una tetera\"\n        case _:\n            return \"Error desconocido\"\n</code></pre> <p>La sentencia match puede desempaquetar tuplas o atributos de objetos, lo que la hace \u00fatil para comparar estructuras de datos complejas</p>"},{"location":"estructurasControl/#2-bucles","title":"2. Bucles","text":"<p>Bucle for</p> <p>El bucle for de Python itera directamente sobre los elementos de una secuencia (listas, tuplas, cadenas, conjuntos, diccionarios, generadores, etc.), no sobre \u00edndices como en C, Java o PHP. Para recorrer n\u00fameros en progresi\u00f3n se utiliza la funci\u00f3n integrada range() que genera una sucesi\u00f3n aritm\u00e9tica sin crear una lista completa en memoria.</p> <ul> <li>range(fin) genera n\u00fameros desde 0 hasta fin-1.</li> <li>range(inicio, fin, paso) permite especificar un valor inicial, final (exclusivo) y un incremento (puede ser negativo)</li> <li>Es posible iterar sobre los \u00edndices de una lista combinando range() y len(), aunque la funci\u00f3n enumerate() resulta m\u00e1s c\u00f3moda porque devuelve pares (\u00edndice, elemento) y evita tener que calcular la longitud manualmente.</li> </ul> <pre><code>flowchart TD\n    A([Inicio]) --&gt; I[Iterador]\n    I --&gt; L{Quedan elementos}\n    L -- No --&gt; ELS[Ejecuta else] --&gt; Z([Fin])\n    L -- Si --&gt; GET[Tomar elemento]\n    GET --&gt; B?{break}\n    B? -- Si --&gt; Z\n    B? -- No --&gt; C?{continue}\n    C? -- Si --&gt; L\n    C? -- No --&gt; BODY[Cuerpo for]\n    BODY --&gt; L\n\n\n</code></pre> <pre><code># Recorrer una lista de forma directa\nnombres = [\"Ana\", \"Luis\", \"Sof\u00eda\"]\nfor nombre in nombres:\n    print(nombre.upper())\n\n# Recorrer n\u00fameros con range\nfor i in range(5):      # 0, 1, 2, 3, 4\n    print(i)\n\n# Range con inicio y paso\nfor i in range(1, 10, 2):  # 1, 3, 5, 7, 9\n    print(i)\n\n# Usando enumerate para obtener \u00edndice y valor\nfor indice, valor in enumerate([10, 20, 30]):\n    print(f\"\u00cdndice {indice}: {valor}\")\n\n# Iterar dos listas a la vez con zip\nnombres = [\"Ana\", \"Luis\", \"Sof\u00eda\"]\nedades  = [20, 22, 19]\nfor nombre, edad in zip(nombres, edades):\n    print(f\"{nombre} tiene {edad} a\u00f1os\")\n\n</code></pre> <p>Control de bucles</p> <ul> <li><code>break</code> sale inmediatamente del bucle m\u00e1s interno.</li> <li><code>continue</code> salta a la siguiente iteraci\u00f3n del bucle, sin ejecutar el resto del bloque</li> <li>Un bucle <code>for</code> o <code>while</code> puede tener un <code>else</code>, que se ejecuta solo si el bucle termina sin un <code>break</code> . Es \u00fatil para buscar elementos: si no se encuentran, el else notifica la ausencia.</li> <li><code>pass</code>:  no hace nada y sirve como marcador de posici\u00f3n en bloques vac\u00edo</li> </ul> <pre><code># Buscar un n\u00famero primo utilizando for-else\nfor n in range(2, 10):\n    for x in range(2, n):\n        if n % x == 0:\n            print(f\"{n} es igual a {x} \u00d7 {n//x}\")\n            break  # sale del bucle interior\n    else:\n        # se ejecuta si no se encontr\u00f3 divisor (no hubo break)\n        print(f\"{n} es un n\u00famero primo\")\n\n# Uso de continue para saltar n\u00fameros pares\nfor num in range(2, 10):\n    if num % 2 == 0:\n        print(f\"Encontrado par {num}\")\n        continue  # salta a la siguiente iteraci\u00f3n\n    print(f\"Encontrado impar {num}\")\n</code></pre> <pre><code># Tabla de multiplicar del 1 al 3 (for anidado)\nfor i in range(1, 4):\n    for j in range(1, 4):\n        print(f\"{i} \u00d7 {j} = {i*j}\")\n    print(\"---\")\n</code></pre> <p>Bucle while</p> <p>El bucle while repite su cuerpo mientras la condici\u00f3n se mantenga verdadera. Es \u00fatil para bucles de duraci\u00f3n indeterminada y se debe actualizar la condici\u00f3n dentro del bucle para evitar iteraciones infinitas. Al igual que en el for, se puede utilizar un else para ejecutar un bloque cuando el bucle termina de forma natura</p> <pre><code>flowchart TD\n    A([Inicio]) --&gt; C{condicion while}\n    C -- No --&gt; ELS[Ejecuta else] --&gt; Z([Fin])\n    C -- Si --&gt; BODY[Cuerpo while]\n    BODY --&gt; B?{break}\n    B? -- Si --&gt; Z\n    B? -- No --&gt; CONT?{continue}\n    CONT? -- Si --&gt; C\n    CONT? -- No --&gt; C\n\n\n</code></pre> <pre><code>x = 5\nwhile x &gt; 0:\n    print(x)\n    x -= 1\nelse:\n    print(\"\u00a1Despegue!\")\n</code></pre> <p>Bucles anidados y pass</p> <p>Se pueden anidar bucles for y while dentro de otros. Python dispone de la sentencia pass que no hace nada y sirve como marcador de posici\u00f3n en bloques vac\u00edo</p> <pre><code># Tabla de multiplicar del 1 al 3 (for anidado)\nfor i in range(1, 4):\n    for j in range(1, 4):\n        print(f\"{i} \u00d7 {j} = {i*j}\")\n    print(\"---\")\n\n# Bucle while anidado dentro de otro while\nfila = 1\nwhile fila &lt;= 3:\n    columna = 1\n    while columna &lt;= 3:\n        print(f\"Fila {fila}, Columna {columna}\")\n        columna += 1\n    fila += 1\n\n# Bloque pass como placeholder\nfor i in range(3):\n    pass  # se usa cuando a\u00fan no se ha implementado el bloque\n</code></pre>"},{"location":"estructurasControl/#3-manejo-de-errores","title":"3. Manejo de errores","text":"<p>Python diferencia entre errores de sintaxis y excepciones. Los errores sint\u00e1cticos impiden que el programa arranque, mientras que las excepciones ocurren durante la ejecuci\u00f3n y pueden ser atrapadas y gestionadas. Las excepciones predefinidas como ZeroDivisionError, NameError o TypeError indican qu\u00e9 clase de problema ocurri\u00f3.</p> <p><code>try...except</code></p> <p>El bloque <code>try</code> se utiliza para envolver el c\u00f3digo que podr\u00eda generar un error. Si se produce una excepci\u00f3n dentro del bloque, se buscan cl\u00e1usulas <code>except</code> que la manejen. Se pueden capturar tipos espec\u00edficos o un conjunto de ellos usando una tupla. Capturar excepciones espec\u00edficas ayuda a identificar mejor los problemas y no ocultar errores inesperados.</p> <p><code>else  finally</code></p> <p>La cl\u00e1usula <code>else</code> debe seguir a todos los except y se ejecuta solo si el bloque <code>try</code> no genera ninguna excepci\u00f3n. Es \u00fatil para colocar c\u00f3digo que debe ejecutarse cuando todo ha ido bien, evitando interceptar excepciones fuera de lugar.</p> <p>La cl\u00e1usula <code>finally</code> se ejecuta siempre, tanto si hay una excepci\u00f3n como si no. Se usa para realizar tareas de limpieza: cerrar archivos, liberar recursos o mostrar mensajes finales.</p> <pre><code>flowchart TD\n    A([Inicio]) --&gt; TRY[try]\n    TRY --&gt; EXC{excepcion?}\n    EXC -- No --&gt; ELSE[else]\n    EXC -- Si --&gt; CHK1{except 1}\n    CHK1 -- Si --&gt; H1[Manejar exc 1]\n    CHK1 -- No --&gt; CHK2{except 2}\n    CHK2 -- Si --&gt; H2[Manejar exc 2]\n    CHK2 -- No --&gt; PROP[Propagar error]\n    ELSE --&gt; FINALLY[finally]\n    H1 --&gt; FINALLY\n    H2 --&gt; FINALLY\n    PROP --&gt; FINALLY\n    FINALLY --&gt; Z([Fin])\n\n</code></pre> <pre><code>try:\n    num = int(input(\"Introduce un n\u00famero: \"))\n    resultado = 10 / num\nexcept ZeroDivisionError:\n    print(\"No puedes dividir entre 0\")\nexcept ValueError:\n    print(\"Debes introducir un n\u00famero v\u00e1lido\")\nexcept (TypeError, NameError):\n    print(\"Otro tipo de error\")\nelse:\n    # se ejecuta solo si no hubo excepci\u00f3n\n    print(f\"El resultado es {resultado}\")\nfinally:\n    # se ejecuta siempre, haya o no excepci\u00f3n\n    print(\"Ejecuci\u00f3n finalizada\")\n</code></pre>"},{"location":"gestionarchivos/","title":"Gesti\u00f3n de archivos","text":""},{"location":"gestionarchivos/#objetivos","title":"Objetivos","text":"<ul> <li>Entender c\u00f3mo abrir, cerrar, leer y escribir archivos en Python de forma segura.</li> <li>Diferenciar entre modos de apertura (lectura, escritura, a\u00f1adir; texto vs binario) y saber cu\u00e1ndo usar cada uno  </li> <li>Utilizar el gestor de contexto with para garantizar el cierre autom\u00e1tico de los archivos  </li> <li>Eliminar y renombrar archivos y directorios mediante el m\u00f3dulo os  </li> <li>Manipular distintos tipos de archivos: texto plano, CSV y JSON, utilizando los m\u00f3dulos csv y json de la biblioteca est\u00e1ndar  </li> </ul>"},{"location":"gestionarchivos/#1-manejo-basico-de-archivos","title":"1. Manejo b\u00e1sico de archivos","text":"<p>Para trabajar con archivos en Python se utiliza la funci\u00f3n incorporada open(), que devuelve un objeto de archivo. Su llamada m\u00e1s com\u00fan acepta tres argumentos: nombre de archivo, modo de apertura y codificaci\u00f3n  </p> <pre><code>f = open('datos.txt', 'w', encoding='utf-8')\n</code></pre> <ul> <li>Primer argumento ('datos.txt'): ruta o nombre del archivo.  </li> <li>Segundo argumento ('w'): modo de apertura. Los m\u00e1s utilizados son:  </li> <li>'r' lectura (por defecto). El archivo debe existir.  </li> <li>'w' escritura. Crea un archivo nuevo o trunca el existente  </li> <li>'a' a\u00f1adir. Abre el archivo para append; lo nuevo se a\u00f1ade al final  </li> <li>'r+' lectura y escritura.  </li> <li> <p>A\u00f1adir 'b' lo abre en modo binario (lee y escribe objetos bytes). Sin 'b' se trabaja en modo texto, que lee y escribe cadenas con un determinado encoding  </p> </li> <li> <p>Tercer argumento (encoding='utf-8'): codificaci\u00f3n del texto. Se recomienda especificarlo para evitar problemas con caracteres especiales  </p> </li> </ul>"},{"location":"gestionarchivos/#uso-del-gestor-de-contexto","title":"Uso del gestor de contexto","text":"<p>Para asegurar que el archivo se cierra correctamente, incluso si ocurre una excepci\u00f3n, se usa el gestor de contexto with:</p> <pre><code>with open('datos.txt', 'w', encoding='utf-8') as f:\n    f.write('Primera l\u00ednea\\n')  # el archivo se cierra autom\u00e1ticamente al salir del bloque\n</code></pre> <p>Al finalizar el bloque with, el archivo se cierra sin necesidad de llamar a f.close()  </p>"},{"location":"gestionarchivos/#lectura-de-archivos","title":"Lectura de archivos","text":"<p>Una vez abierto un archivo en modo lectura ('r'), existen varias formas de obtener su contenido:</p> <ul> <li>f.read([size]): lee todo el archivo o size caracteres/bytes  </li> <li>f.readline(): lee una l\u00ednea completa  </li> <li>Iterar sobre el archivo: recorrerlo con for line in f  </li> <li>f.readlines(): devuelve una lista con todas las l\u00edneas del archivo  </li> </ul>"},{"location":"gestionarchivos/#escritura-de-archivos","title":"Escritura de archivos","text":"<ul> <li>f.write(cadena): escribe la cadena y devuelve el n\u00famero de caracteres escritos  </li> <li>Importante: convertir otros tipos a cadena antes de escribirlos  </li> </ul>"},{"location":"gestionarchivos/#posicionamiento","title":"Posicionamiento","text":"<ul> <li>f.tell() y f.seek(offset, whence) permiten conocer y modificar la posici\u00f3n actual del puntero  </li> </ul>"},{"location":"gestionarchivos/#2-eliminacion-y-renombrado-de-archivos","title":"2. Eliminaci\u00f3n y renombrado de archivos","text":"<p>El m\u00f3dulo os proporciona funciones para manipular el sistema de archivos:</p> <pre><code>import os\n\n# eliminar un archivo\nos.remove('datos.txt')  # lanza FileNotFoundError si no existe\n\n# renombrar\nos.rename('datos_viejos.txt', 'datos_nuevos.txt')\n\n# borrar un directorio vac\u00edo\nos.rmdir('carpeta_vacia')\n</code></pre> <p>Para operaciones de alto nivel el m\u00f3dulo shutil ofrece funciones como shutil.copy(), shutil.move() y shutil.rmtree().</p>"},{"location":"gestionarchivos/#3-tipos-de-archivos-y-bibliotecas-estandar","title":"3. Tipos de archivos y bibliotecas est\u00e1ndar","text":""},{"location":"gestionarchivos/#31-texto-plano","title":"3.1 Texto plano","text":"<p>Los archivos de texto plano (extensiones .txt, .log, etc.) se leen y escriben como cadenas en modo texto. La codificaci\u00f3n y la conversi\u00f3n autom\u00e1tica de saltos de l\u00ednea se gestionan al abrir el archivo  Estos archivos son ideales para guardar informaci\u00f3n sencilla lineal o registros de log.</p>"},{"location":"gestionarchivos/#32-csv","title":"3.2 CSV","text":"<p>El m\u00f3dulo csv simplifica la lectura y escritura de archivos Comma Separated Values. Para leer un CSV se utiliza csv.reader, que devuelve un reader object. Cada fila se devuelve como una lista de cadenas y no se realiza conversi\u00f3n de tipos autom\u00e1ticamente  El archivo debe abrirse con newline='' para evitar que el m\u00f3dulo convierta los saltos de l\u00ednea de manera incorrecta.</p> <pre><code>import csv\n\n# Leer un CSV\nwith open('alumnos.csv', newline='', encoding='utf-8') as csvfile:\n    lector = csv.reader(csvfile, delimiter=';', quotechar='\"')\n    for fila in lector:\n        nombre, edad, ciudad = fila\n        print(nombre, edad, ciudad)\n\n# Escribir un CSV\nwith open('salida.csv', 'w', newline='', encoding='utf-8') as csvfile:\n    escritor = csv.writer(csvfile, delimiter=';', quotechar='\"', quoting=csv.QUOTE_MINIMAL)\n    escritor.writerow(['Nombre', 'Edad', 'Ciudad'])\n    escritor.writerow(['Ana', 30, 'Barcelona'])\n</code></pre> <p>Para trabajar con diccionarios se utilizan csv.DictReader y csv.DictWriter  </p>"},{"location":"gestionarchivos/#33-json","title":"3.3 JSON","text":"<p>El formato JSON (JavaScript Object Notation) almacena estructuras de datos como diccionarios y listas. El m\u00f3dulo json permite serializar objetos Python a JSON (json.dump() y json.dumps()) y deserializar JSON a objetos Python (json.load() y json.loads()).</p> <p>Serializar a archivo: json.dump(objeto, archivo) escribe el objeto en formato JSON en un archivo. El archivo debe estar abierto en modo escritura y aceptar cadenas (str)</p> <p>Serializar a cadena: json.dumps(objeto) devuelve una cadena JSON.</p> <p>Leer de archivo: json.load(archivo) lee el JSON del archivo y lo convierte en una estructura de datos Python </p> <p>Leer desde cadena: json.loads(cadena) deserializa una cadena JSON a Python.</p> <p>Las claves en un objeto JSON siempre son cadenas; convertir un diccionario con claves de otro tipo puede alterar la estructura.</p> <pre><code>import json\n\ndatos = {\n    'alumnos': [\n        {'nombre': 'Ana', 'edad': 25},\n        {'nombre': 'Luis', 'edad': 23}\n    ]\n}\n\n# Escribir JSON en un archivo\nwith open('datos.json', 'w', encoding='utf-8') as f:\n    json.dump(datos, f, indent=4)\n\n# Leer JSON desde un archivo\nwith open('datos.json', encoding='utf-8') as f:\n    datos_cargados = json.load(f)\n    print(datos_cargados['alumnos'][0]['nombre'])  # 'Ana'\n</code></pre> <p>La funci\u00f3n indent en json.dump() genera un fichero legible.  </p>"},{"location":"guia_python_vscode_windows/","title":"Gu\u00eda r\u00e1pida: Python + VS Code en Windows","text":""},{"location":"guia_python_vscode_windows/#1-instalar-python-en-windows","title":"1. Instalar Python en Windows","text":"<ol> <li>Descarga el instalador desde python.org &gt; Downloads &gt; Windows.</li> <li>Ejecuta el instalador y marca \u201cAdd python.exe to PATH\u201d, luego pulsa Install Now.</li> <li>Verifica en una terminal (PowerShell o CMD):</li> </ol> <p><code>powershell    python --version    py --version</code></p> <p>Si PowerShell bloquea la activaci\u00f3n de entornos virtuales:</p> <p><code>powershell Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy RemoteSigned</code></p>"},{"location":"guia_python_vscode_windows/#2-visual-studio-code-extensiones-necesarias-modulos","title":"2. Visual Studio Code + extensiones necesarias + modulos","text":"<p>Instala VS Code y a\u00f1ade estas extensiones:</p> <ul> <li>Python \u2013 ms-python.python</li> <li>Pylance \u2013 ms-python.vscode-pylance</li> <li>Jupyter \u2013 ms-toolsai.jupyter (si usar\u00e1s notebooks)</li> </ul> <p>Para utilizar Jupyter es necesario instalar tambi\u00e9n</p> <pre><code>pip install ipykernel\n</code></pre>"},{"location":"guia_python_vscode_windows/#3-crear-y-usar-un-entorno-virtual-venv","title":"3. Crear y usar un entorno virtual (venv)","text":"<p>En la carpeta del proyecto:</p> <p>Crear</p> <pre><code>py -m venv .venv\n</code></pre> <p>*py o python dependiendo como hayas instalado el ejecutable</p> <p>Activar</p> <pre><code># PowerShell\n. .\\.venv\\Scripts\\Activate.ps1\n</code></pre> <pre><code>:: CMD cl\u00e1sico\n.\\.venv\\Scripts\\activate.bat\n</code></pre> <p>Ver\u00e1s <code>(.venv)</code> al inicio de la l\u00ednea en la terminal cuando est\u00e9 activo.</p> <p>Usar en VS Code</p> <p>Habitualmente VS Code detecta el env, sino es as\u00ed proceder de la siguiente forma:</p> <ul> <li>Abre tu carpeta de proyecto.</li> <li><code>Ctrl+Shift+P</code> \u2192 Python: Select Interpreter \u2192 (elige el de tu venv cuando lo tengas).</li> </ul> <p>Si quieres que este entorno se inicie siempre al abrir el proyecto edita o crea en el directorio .vscode/settgins.json con lo siguiente</p> <pre><code>{\n    \"python-envs.pythonProjects\": [],\n    \"python.defaultInterpreterPath\": \".venv\\\\Scripts\\\\python.exe\"\n}```\n\n\n### Instalar paquetes y guardar dependencias\n\n```powershell\npip install requests\npip freeze &gt; requirements.txt\n</code></pre> <p>Para restaurar en otra m\u00e1quina:</p> <pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"guia_python_vscode_windows/#4-ajustes-basicos-recomendados-en-vs-code","title":"4. Ajustes b\u00e1sicos recomendados en VS Code","text":"<p>En <code>settings.json</code>:</p> <pre><code>{\n  \"python.testing.pytestEnabled\": true,\n  \"python.analysis.typeCheckingMode\": \"basic\",\n  \"python.defaultInterpreterPath\": \".venv/Scripts/python.exe\",\n  \"editor.formatOnSave\": true\n}\n</code></pre>"},{"location":"guia_python_vscode_windows/#5-consejos-rapidos","title":"5. Consejos r\u00e1pidos","text":"<ul> <li>A\u00f1ade <code>.venv/</code> a tu .gitignore.</li> <li>Usa un venv por proyecto para evitar choques de versiones.</li> <li>En notebooks, selecciona el kernel correspondiente al venv (barra superior del <code>.ipynb</code>).</li> </ul>"},{"location":"practica1/","title":"Practica 1","text":""},{"location":"practica1/#objetivos","title":"Objetivos","text":"<ul> <li>Consolidar el uso de variables simples, entrada de datos con <code>input()</code> y salida con <code>print()</code>.  </li> <li>Practicar condicionales (<code>if</code>/<code>else</code>) y bucles <code>while</code> para repetir acciones seg\u00fan un contador.  </li> <li>Trabajar con datos num\u00e9ricos y realizar comparaciones para contar y encontrar valores m\u00ednimos.  </li> <li>Crear un programa completo sin emplear funciones, diccionarios ni listas, de modo que el alumno se concentre en el flujo de control b\u00e1sico.</li> </ul>"},{"location":"practica1/#1-enunciado-del-ejercicio","title":"1. Enunciado del ejercicio","text":"<p>Se pide desarrollar un peque\u00f1o programa que lea informaci\u00f3n sobre varios empleados y sus horarios de entrada y salida.</p> <ol> <li>Preguntar al usuario cu\u00e1ntos empleados va a introducir y pedir una hora de referencia (0\u201323) para comparar las entradas.  </li> <li>Iterar tantas veces como empleados haya indicado el usuario. En cada iteraci\u00f3n se solicitar\u00e1 el nombre del empleado y sus horas de entrada y salida (enteros entre 0 y 23). Se debe validar que la hora de salida sea mayor que la de entrada.  </li> <li>Contar cu\u00e1ntos empleados han entrado antes o a la hora de referencia.  </li> <li>Determinar qu\u00e9 empleado tiene la salida m\u00e1s temprana.  </li> <li>Mostrar al final del programa el n\u00famero de empleados que cumplen la condici\u00f3n y el nombre de quien sali\u00f3 primero.</li> </ol>"},{"location":"practica1/#2-claves-de-implementacion","title":"2. Claves de implementaci\u00f3n","text":"<ol> <li> <p>Variables iniciales. Declara variables para llevar el recuento de entradas (<code>contador_entradas</code>) y para almacenar la salida m\u00e1s temprana (<code>salida_mas_temprana</code>) y el nombre del empleado correspondiente. </p> </li> <li> <p>Entrada de datos. Utiliza la funci\u00f3n <code>input()</code> para pedir al usuario el n\u00famero de empleados y la hora de referencia, y convi\u00e9rtelos a enteros. Valida que sean n\u00fameros positivos y que la hora est\u00e9 en el rango 0\u201323. Si la validaci\u00f3n falla, muestra un mensaje y termina la ejecuci\u00f3n o solicita de nuevo los datos.</p> </li> <li> <p>Bucle de iteraci\u00f3n. Emplea un bucle <code>while</code> con un contador para pedir los datos de cada empleado. Este tipo de bucle repite sus instrucciones mientras la condici\u00f3n sea verdadera.</p> </li> <li> <p>Solicita el nombre y las horas de entrada y salida.  </p> </li> <li>Convierte las horas a enteros y comprueba que est\u00e9n en el intervalo permitido. Si no lo est\u00e1n o la salida no supera a la entrada, muestra un mensaje y repite la iteraci\u00f3n sin avanzar el contador.  </li> <li>Compara la hora de entrada con la hora de referencia; si es menor o igual, incrementa <code>contador_entradas</code>.  </li> <li>Compara la hora de salida con <code>salida_mas_temprana</code>; si es menor, actualiza ambas variables con la nueva salida y el nombre del empleado.  </li> <li> <p>Incrementa el contador del bucle para pasar al siguiente empleado.</p> </li> <li> <p>Salida de resultados. Despu\u00e9s de salir del bucle, utiliza <code>print()</code> para mostrar el n\u00famero de empleados que entraron antes o a la hora de referencia y, si se determin\u00f3 alguno, el nombre y la hora de la salida m\u00e1s temprana.</p> </li> </ol>"},{"location":"practica1/#3-sugerencias-de-depuracion","title":"3. Sugerencias de depuraci\u00f3n","text":"<p>En Visual Studio Code, abre el archivo <code>.py</code> y utiliza el panel Run and Debug para depurar el script. Selecciona Python File como configuraci\u00f3n, establece un punto de ruptura en la l\u00ednea de actualizaci\u00f3n de <code>salida_mas_temprana</code> y ejecuta la depuraci\u00f3n. Podr\u00e1s observar la evoluci\u00f3n de las variables en los paneles de variables y la pila de llamadas.</p>"},{"location":"practica2/","title":"Practica 2","text":""},{"location":"practica2/#objetivos","title":"Objetivos","text":"<ul> <li>Primer contacto con las funciones en Python y por qu\u00e9 se utilizan para estructurar programas.  </li> <li>Aprender a definir funciones con la palabra reservada <code>def</code>.  </li> <li>Aplicar estructuras b\u00e1sicas como diccionarios, bucles <code>for</code> y condicionales para resolver un problema sencillo de control de horarios.  </li> <li>Practicar t\u00e9cnicas de depuraci\u00f3n con el depurador incorporado de Python y conocer los pasos para depurar en Visual Studio Code.  </li> </ul>"},{"location":"practica2/#1-por-que-utilizar-funciones-con-def","title":"1. \u00bfPor qu\u00e9 utilizar funciones con <code>def</code>?","text":"<p>En Python, una funci\u00f3n es un bloque de c\u00f3digo reutilizable que se define mediante la palabra clave <code>def</code>, seguida del nombre de la funci\u00f3n, una lista de par\u00e1metros opcionales entre par\u00e9ntesis y dos puntos. Todo el cuerpo de la funci\u00f3n debe ir indentado.  </p> <p>Al invocar una funci\u00f3n, Python crea una tabla de s\u00edmbolos local donde se guardan los par\u00e1metros y las variables definidas en el cuerpo. Esto significa que las variables asignadas dentro de una funci\u00f3n no afectan a las variables fuera de ella.</p> <p>Si una funci\u00f3n no incluye la sentencia <code>return</code>, devolver\u00e1 autom\u00e1ticamente el objeto especial <code>None</code> al terminar.  </p>"},{"location":"practica2/#2-descripcion-del-programa","title":"2. Descripci\u00f3n del programa","text":"<p>El programa <code>horario_minimo.py</code> es un ejercicio introductorio en el que se gestiona un conjunto de horarios de empleados: los datos est\u00e1n codificados directamente en el propio script mediante un diccionario.  </p> <p>Cada entrada del diccionario asocia el nombre de una persona con una tupla de dos cadenas, la primera indicando la hora de entrada y la segunda la hora de salida.  </p> <p>Ejemplo: <code>'Mar\u00eda': ('08', '16')</code> indica que Mar\u00eda entra a las 8 h y sale a las 16 h.  </p> <p>El programa define tres funciones principales:</p> <ul> <li><code>mostrar_registros()</code> \u2013 Recorre el diccionario y muestra todos los empleados con sus horas. Utiliza <code>enumerate(horarios.items(), start=1)</code> para numerar la salida comenzando en uno.  </li> <li><code>contar_entradas()</code> \u2013 Solicita al usuario una hora (0\u201323), valida la entrada y cuenta cu\u00e1ntas personas han llegado antes o a esa hora.  </li> <li><code>menu()</code> \u2013 Presenta un men\u00fa repetitivo mediante un bucle <code>while</code> para que el usuario elija entre mostrar registros, contar entradas o salir.  </li> </ul> <p>Mediante estas funciones, el programa demuestra c\u00f3mo dividir el c\u00f3digo en bloques l\u00f3gicos e interactuar con el usuario de forma sencilla.  </p>"},{"location":"practica2/#3-como-crear-el-programa","title":"3. C\u00f3mo crear el programa","text":""},{"location":"practica2/#definir-los-datos","title":"Definir los datos","text":"<pre><code>horarios = {\n    'Mar\u00eda': ('08', '16'),\n    'Juan':  ('09', '17'),\n    # ... m\u00e1s entradas\n}\n</code></pre>"},{"location":"practica2/#mostrar-registros","title":"Mostrar registros","text":"<p>Define una funci\u00f3n <code>mostrar_registros()</code> que recorra el diccionario. Para numerar los elementos a partir de 1, usa:</p> <pre><code>enumerate(horarios.items(), start=1)\n</code></pre>"},{"location":"practica2/#contar-entradas","title":"Contar entradas","text":"<p>Crea una funci\u00f3n <code>contar_entradas()</code> que solicite al usuario una hora en formato entero (0\u201323).  </p> <ul> <li>Valida la entrada con <code>try/except</code>.  </li> <li>Inicializa un contador en cero.  </li> <li>Convierte la hora de entrada a entero y comp\u00e1rala con la hora introducida.  </li> <li>Incrementa el contador si corresponde.  </li> </ul>"},{"location":"practica2/#menu-principal","title":"Men\u00fa principal","text":"<p>Implementa una funci\u00f3n <code>menu()</code> que muestre un men\u00fa textual con tres opciones:  </p> <ol> <li>Mostrar registros  </li> <li>Contar entradas  </li> <li>Salir  </li> </ol> <p>El men\u00fa debe ejecutarse hasta que el usuario introduzca la opci\u00f3n de salida.  </p>"},{"location":"practica2/#punto-de-entrada","title":"Punto de entrada","text":"<pre><code>if __name__ == '__main__':\n    menu()\n</code></pre>"},{"location":"practica2/#5-depuracion-en-visual-studio-code","title":"5. Depuraci\u00f3n en Visual Studio Code","text":"<p>Pasos:</p> <ol> <li>Abrir la carpeta que contiene <code>horario_minimo.py</code>.  </li> <li>Ir a Run and Debug (Ctrl+Shift+D) y seleccionar Python File.  </li> </ol> <p>VS Code generar\u00e1 un <code>launch.json</code> para configurar la depuraci\u00f3n.  </p> <p>Ahora puedes:  </p> <ul> <li>Colocar puntos de ruptura con clic en el margen.  </li> <li>Ejecutar con F5.  </li> <li>Observar variables, pila de llamadas y usar la consola interactiva.  </li> </ul> <p>Si necesitas pausar la ejecuci\u00f3n desde el propio c\u00f3digo:</p> <pre><code>import debugpy\ndebugpy.breakpoint()\n</code></pre>"},{"location":"practica2/#6-actividades-sugeridas","title":"6. Actividades sugeridas","text":"<ul> <li>Ampliar los horarios \u2013 A\u00f1ade un par de empleados m\u00e1s al diccionario <code>horarios</code>. \u00bfCambia algo en el resto del programa?  </li> <li>Validar la entrada \u2013 Mejora <code>contar_entradas()</code> para aceptar horas con minutos (<code>'08:30'</code>).  </li> <li>Refactorizar el c\u00f3digo \u2013 Crea una funci\u00f3n para la validaci\u00f3n de la hora y reutil\u00edzala.  </li> <li>Practicar con <code>enumerate</code> \u2013 Cambia la numeraci\u00f3n inicial a 0 en <code>mostrar_registros()</code>.  </li> <li>Depuraci\u00f3n visual \u2013 Usa VS Code para depurar <code>contar_entradas()</code>.  </li> </ul>"},{"location":"practica3/","title":"Practica 3","text":""},{"location":"practica3/#objetivos","title":"Objetivos","text":"<ul> <li>Integrar clases, conjuntos y ficheros CSV en un \u00fanico proyecto.</li> <li>Leer informaci\u00f3n de horarios de un archivo CSV, crear objetos que representen cada registro y procesarla.</li> <li>Utilizar sets para eliminar duplicados y aplicar operaciones de uni\u00f3n, intersecci\u00f3n y diferencia.</li> <li>Guardar los resultados en un nuevo archivo CSV utilizando el m\u00f3dulo csv de la biblioteca est\u00e1ndar</li> </ul>"},{"location":"practica3/#1-enunciado-de-la-practica","title":"1. Enunciado de la pr\u00e1ctica","text":"<p>Supongamos que gestionas los horarios de un grupo de empleados. Tienes un fichero <code>horarios.csv</code> con los campos:</p> <pre><code>nombre_empleado;dia;hora_entrada;hora_salida\n</code></pre> <p>Cada l\u00ednea contiene el nombre de un empleado, el d\u00eda de la semana y sus horas de entrada y salida (valores enteros de 0\u201323). El objetivo de la pr\u00e1ctica es:</p> <ul> <li>Leer el fichero CSV y convertir cada l\u00ednea en un objeto de una clase <code>RegistroHorario</code> que almacene los datos de forma estructurada.</li> <li>Construir conjuntos de empleados para cada d\u00eda y aplicar operaciones de teor\u00eda de conjuntos (uni\u00f3n, intersecci\u00f3n y diferencia) para responder a preguntas como: \u00bfqu\u00e9 empleados trabajaron en todos los d\u00edas? \u00bfQui\u00e9nes trabajaron s\u00f3lo en un d\u00eda concreto?.</li> <li>Calcular estad\u00edsticas (por ejemplo, horas totales trabajadas por cada empleado) y guardar los resultados en un nuevo fichero <code>resumen_horarios.csv</code>.</li> </ul> <p>Al final de la pr\u00e1ctica deber\u00e1s producir un programa completo que lea los datos, los procese y genere los resultados solicitados.</p>"},{"location":"practica3/#2-clase-registrohorario","title":"2. Clase RegistroHorario","text":"<p>Para representar cada entrada de <code>horarios.csv</code> definiremos la clase <code>RegistroHorario</code>. Esta clase contendr\u00e1 los atributos <code>empleado</code>, <code>dia</code>, <code>entrada</code> y <code>salida</code>, y un m\u00e9todo que calcule la duraci\u00f3n del turno en horas.</p> <pre><code>class RegistroHorario:\n    def __init__(self, empleado: str, dia: str, entrada: int, salida: int):\n        self.empleado = empleado\n        self.dia = dia\n        self.entrada = entrada\n        self.salida = salida\n\n    def duracion(self) -&gt; int:\n        \"\"\"Devuelve la cantidad de horas trabajadas en este registro\"\"\"\n        return self.salida - self.entrada\n</code></pre> <p>Cada vez que crees una instancia con <code>RegistroHorario('Ana','Lunes',9,17)</code> se almacenar\u00e1n los valores en los atributos correspondientes. El m\u00e9todo <code>duracion</code> devuelve la diferencia entre la hora de salida y la de entrada.</p>"},{"location":"practica3/#3-lectura-del-csv-y-creacion-de-objetos","title":"3. Lectura del CSV y creaci\u00f3n de objetos","text":"<p>Python dispone del m\u00f3dulo <code>csv</code> para leer archivos en formato Comma Separated Values. La funci\u00f3n <code>csv.reader</code> devuelve un objeto lector que itera sobre las filas del archivo y entrega cada fila como una lista de cadenas.</p> <ul> <li>Es importante abrir el archivo con <code>newline=''</code> para que el m\u00f3dulo gestione correctamente los saltos de l\u00ednea</li> <li>La conversi\u00f3n de campos a n\u00fameros se realiza manualmente.</li> </ul> <p>El siguiente ejemplo ilustra c\u00f3mo leer <code>horarios.csv</code> y crear una lista de objetos <code>RegistroHorario</code>:</p> <pre><code>import csv\n\nregistros = []\nwith open('horarios.csv', newline='', encoding='utf-8') as f:\n    lector = csv.reader(f, delimiter=';', quotechar='\"')\n    for fila in lector:\n        # Cada fila es una lista de cadenas: [nombre, dia, entrada, salida]\n        nombre, dia, h_entrada, h_salida = fila\n        # Convertimos las horas a enteros\n        entrada = int(h_entrada)\n        salida = int(h_salida)\n        registro = RegistroHorario(nombre, dia, entrada, salida)\n        registros.append(registro)\n\nprint(f\"Se han le\u00eddo {len(registros)} registros\")\n</code></pre> <p>Tras ejecutar este fragmento, dispondr\u00e1s de una lista de objetos <code>RegistroHorario</code> que puedes recorrer y procesar con normalidad. Si el CSV tuviera encabezados, podr\u00edas omitir la primera fila o utilizar <code>csv.DictReader</code> para mapear cada fila a un diccionario.</p>"},{"location":"practica3/#4-conjuntos-para-agrupar-y-operar-con-empleados","title":"4. Conjuntos para agrupar y operar con empleados","text":"<p>Los conjuntos (<code>set</code>) son colecciones desordenadas de elementos \u00fanicos. Son ideales para eliminar duplicados y para realizar operaciones de uni\u00f3n, intersecci\u00f3n y diferencia. Vamos a utilizarlos para crear un conjunto de empleados por cada d\u00eda y comparar qui\u00e9n ha trabajado en varios d\u00edas.</p> <p>Primero, construimos un diccionario que asocie cada d\u00eda con el conjunto de empleados que han trabajado ese d\u00eda:</p> <pre><code>empleados_por_dia = {}\nfor registro in registros:\n    # Creamos el conjunto para el d\u00eda si no existe\n    if registro.dia not in empleados_por_dia:\n        empleados_por_dia[registro.dia] = set()\n    # A\u00f1adimos el empleado al conjunto del d\u00eda\n    empleados_por_dia[registro.dia].add(registro.empleado)\n\n# Mostrar empleados por d\u00eda\nfor dia, empleados in empleados_por_dia.items():\n    print(f\"{dia}: {empleados}\")\n</code></pre> <p>Una vez que tengas estos conjuntos, puedes usar las operaciones de la teor\u00eda de conjuntos:</p> <ul> <li> <p>Uni\u00f3n (|): empleados que trabajaron en al menos alguno de los d\u00edas. Por ejemplo, <code>empleados_por_dia['Lunes'] | empleados_por_dia['Martes']</code> devuelve el conjunto de empleados que trabajaron el lunes o el martes.</p> </li> <li> <p>Intersecci\u00f3n (&amp;): empleados que trabajaron en ambos d\u00edas. Por ejemplo, <code>empleados_por_dia['Lunes'] &amp; empleados_por_dia['Martes']</code> devuelve quienes trabajaron los dos d\u00edas.</p> </li> <li> <p>Diferencia (-): empleados que trabajaron en un d\u00eda pero no en otro; <code>empleados_por_dia['Lunes'] - empleados_por_dia['Martes']</code> lista quienes trabajaron s\u00f3lo el lunes.</p> </li> <li> <p>Diferencia sim\u00e9trica (^): empleados que trabajaron en exactamente uno de los d\u00edas, pero no en ambos.</p> </li> </ul> <p>Los conjuntos tambi\u00e9n se pueden construir con set comprehensions, una sintaxis compacta que permite aplicar filtros mientras se construye el conjunto. Por ejemplo, para obtener la lista de empleados que han trabajado al menos 8 horas en alg\u00fan d\u00eda:</p> <pre><code>empleados_turno_largo = {r.empleado for r in registros if r.duracion() &gt;= 8}\nprint(empleados_turno_largo)\n</code></pre>"},{"location":"practica3/#5-calculo-de-estadisticas-y-escritura-del-resultado-en-csv","title":"5. C\u00e1lculo de estad\u00edsticas y escritura del resultado en CSV","text":"<p>Adem\u00e1s de usar conjuntos para comparar empleados, es habitual resumir la informaci\u00f3n en un fichero de salida. Utilizaremos un diccionario para acumular las horas totales trabajadas por cada empleado y luego escribiremos el resultado en un nuevo fichero CSV utilizando <code>csv.writer</code>. Al igual que al leer, el fichero debe abrirse con <code>newline=''</code> y cualquier dato no textual se convertir\u00e1 en cadena autom\u00e1ticamente.</p> <pre><code>import csv\n\n# Calcular horas totales por empleado\nhoras_totales = {}\nfor registro in registros:\n    horas_totales.setdefault(registro.empleado, 0)\n    horas_totales[registro.empleado] += registro.duracion()\n\n# Escribir un resumen en un nuevo CSV\nwith open('resumen_horarios.csv', 'w', newline='', encoding='utf-8') as f:\n    escritor = csv.writer(f, delimiter=';', quotechar='\"', quoting=csv.QUOTE_MINIMAL)\n    # Cabecera\n    escritor.writerow(['Empleado', 'Horas totales'])\n    # Filas con los datos acumulados\n    for empleado, total in horas_totales.items():\n        escritor.writerow([empleado, total])\n\nprint(\"Se ha generado el fichero resumen_horarios.csv\")\n</code></pre> <p>El m\u00f3dulo <code>csv.writer</code> convierte autom\u00e1ticamente los valores no textuales a cadenas antes de escribir. Con estos pasos conseguimos un informe que resume las horas trabajadas por cada empleado.</p>"},{"location":"practica3/#6-ejercicios","title":"6. Ejercicios","text":"<ul> <li> <p>Empleados madrugadores. A\u00f1ade un par\u00e1metro <code>hora_referencia</code> a tu programa y utiliza un conjunto para obtener los nombres de los empleados que comienzan su turno antes de esa hora. Guarda el resultado en un nuevo archivo <code>madrugadores.csv</code> con los campos <code>empleado</code> y <code>hora_entrada</code>.</p> </li> <li> <p>Intersecci\u00f3n de d\u00edas. Calcula el conjunto de empleados que trabajaron tanto el lunes como el viernes. Muestra sus nombres por pantalla y escribe la lista en <code>en_dos_dias.csv</code>.</p> </li> <li> <p>Empleados exclusivos.Crea un conjunto con los empleados que trabajaron el s\u00e1bado pero no el domingo. \u00bfQu\u00e9 operaci\u00f3n de conjuntos has utilizado?</p> </li> <li> <p>Resumen semanal. Completa el ejemplo de la secci\u00f3n 5 para calcular, adem\u00e1s de las horas totales, el n\u00famero de d\u00edas trabajados por cada empleado (puedes usar un <code>set</code> dentro del diccionario para evitar contar d\u00edas repetidos). Escribe el resultado en <code>resumen_semanal.csv</code> con los campos <code>empleado</code>, <code>dias_trabajados</code> y <code>horas_totales</code>.</p> </li> <li> <p>Filtrado por duraci\u00f3n. Usa una set comprehension para obtener el conjunto de empleados que han trabajado al menos 6 horas en todas sus jornadas. Ten en cuenta que necesitar\u00e1s comprobar cada registro de cada empleado.</p> </li> <li> <p>Dise\u00f1ar clases para empleados y gesti\u00f3n. Define una clase Empleado que almacene el nombre de un trabajador y una lista de sus registros (RegistroHorario). Implementa m\u00e9todos para a\u00f1adir registros (agregar_registro), calcular las horas totales trabajadas (horas_totales), obtener el n\u00famero de d\u00edas distintos trabajados (dias_trabajados) y devolver una fila para el CSV de resumen (fila_csv). Adem\u00e1s, crea una clase GestorHorarios que se encargue de leer el fichero de entrada, agrupar los registros por empleado y escribir el resumen en un archivo. Utiliza estas nuevas clases para generar un fichero resumen_clases.csv con los campos empleado, dias_trabajados y horas_totales.</p> </li> </ul>"},{"location":"resumen/","title":"Resumen de sintaxis y funciones de Python","text":"Categor\u00eda Palabra clave / Funci\u00f3n Descripci\u00f3n En el material Definici\u00f3n y POO <code>class</code> Define una clase \u2705 <code>def</code> Define una funci\u00f3n \u2705 <code>return</code> Devuelve un valor desde una funci\u00f3n \u2705 <code>__init__</code> Constructor de clase \u2705 <code>self</code> Referencia a la instancia actual \u2705 <code>pass</code> No hace nada, marcador de posici\u00f3n \u2705 Control de flujo <code>if</code> / <code>elif</code> / <code>else</code> Condicionales \u2705 <code>for</code> Bucle sobre secuencias \u2705 <code>while</code> Bucle mientras la condici\u00f3n sea verdadera \u2705 <code>break</code> Rompe un bucle \u2705 <code>continue</code> Salta a la siguiente iteraci\u00f3n \u2705 <code>match</code> / <code>case</code> Patr\u00f3n de coincidencia (Python 3.10+) \u2705 <code>in</code> / <code>not in</code> Comprueba pertenencia \u2705 <code>is</code> / <code>is not</code> Comparaci\u00f3n de identidad \u2705 Manejo de errores <code>try</code> / <code>except</code> Captura excepciones \u2705 <code>else</code> (en try) Bloque si no hubo excepci\u00f3n \u2705 <code>finally</code> Se ejecuta siempre tras try/except \u2705 <code>raise</code> Lanza una excepci\u00f3n \u274c Entrada / Salida <code>input()</code> Entrada de usuario \u2705 <code>print()</code> Salida en pantalla \u2705 Gesti\u00f3n de ficheros <code>open(nombre, modo, encoding)</code> Abre un archivo y devuelve un objeto fichero \u2705 <code>with open(...) as f:</code> Context manager que asegura cierre autom\u00e1tico \u2705 <code>f.read([size])</code> Lee todo el archivo o <code>size</code> caracteres \u2705 <code>f.readline()</code> Lee una l\u00ednea completa \u2705 <code>f.readlines()</code> Devuelve todas las l\u00edneas como lista \u2705 <code>f.write(cadena)</code> Escribe texto en un archivo \u2705 <code>f.writelines(lista)</code> Escribe una lista de cadenas \u274c <code>f.seek(pos)</code> Cambia la posici\u00f3n del puntero \u2705 <code>f.tell()</code> Devuelve posici\u00f3n actual del puntero \u2705 <code>os.remove()</code> Elimina un archivo \u2705 <code>os.rename()</code> Renombra un archivo \u2705 <code>os.rmdir()</code> Elimina un directorio vac\u00edo \u2705 <code>shutil.copy()</code> Copia un archivo \u2705 <code>shutil.move()</code> Mueve un archivo \u2705 <code>shutil.rmtree()</code> Elimina un directorio con contenido \u2705 <code>csv.reader()</code> Lee un archivo CSV \u2705 <code>csv.writer()</code> Escribe en un archivo CSV \u2705 <code>csv.DictReader()</code> Lee CSV en forma de diccionario \u2705 <code>csv.DictWriter()</code> Escribe CSV desde diccionario \u2705 <code>json.dump()</code> Escribe objeto en JSON a archivo \u2705 <code>json.dumps()</code> Convierte objeto a string JSON \u2705 <code>json.load()</code> Carga objeto desde archivo JSON \u2705 <code>json.loads()</code> Convierte string JSON a objeto \u2705 Funciones \u00fatiles <code>len()</code> Devuelve la longitud \u274c <code>enumerate()</code> Devuelve \u00edndice y valor al iterar \u2705 <code>range()</code> Genera una secuencia de n\u00fameros \u2705 <code>zip()</code> Agrupa elementos de varios iterables \u2705 <code>type()</code> Devuelve el tipo de un objeto \u2705 <code>int()</code>, <code>str()</code>, <code>float()</code> Conversi\u00f3n de tipos \u2705 Strings <code>str.upper()</code> Convierte a may\u00fasculas \u274c <code>str.lower()</code> Convierte a min\u00fasculas \u274c <code>str.title()</code> Capitaliza cada palabra \u274c <code>str.strip()</code> Elimina espacios al inicio/fin \u274c <code>str.split()</code> Divide en lista \u274c <code>str.join()</code> Une lista de strings \u274c <code>str.replace()</code> Reemplaza subcadenas \u274c <code>str.find()</code> Busca una subcadena \u274c Listas <code>list.append()</code> A\u00f1ade un elemento al final \u2705 <code>list.insert()</code> Inserta en posici\u00f3n i \u2705 <code>list.remove()</code> Elimina la primera aparici\u00f3n \u2705 <code>list.pop()</code> Extrae un elemento \u2705 <code>list.sort()</code> Ordena en su lugar \u2705 <code>sorted()</code> Devuelve una lista ordenada \u2705 <code>list.reverse()</code> Invierte la lista \u2705 <code>list.count()</code> Cuenta apariciones \u2705 <code>list.index()</code> Devuelve \u00edndice de elemento \u2705 Conjuntos <code>set.add()</code> A\u00f1ade un elemento \u2705 <code>set.remove()</code> Elimina un elemento (error si no existe) \u2705 <code>set.discard()</code> Elimina un elemento sin error \u2705 <code>set.union()</code> Uni\u00f3n de conjuntos \u2705 <code>set.intersection()</code> Intersecci\u00f3n de conjuntos \u2705 <code>set.difference()</code> Diferencia de conjuntos \u2705 <code>set.clear()</code> Vac\u00eda el conjunto \u2705 Diccionarios <code>dict.get()</code> Obtiene un valor con clave \u2705 <code>dict.keys()</code> Devuelve claves \u2705 <code>dict.values()</code> Devuelve valores \u2705 <code>dict.items()</code> Devuelve pares clave-valor \u2705 <code>dict.update()</code> Actualiza con otro dict \u2705 <code>dict.pop()</code> Elimina clave y devuelve valor \u2705 N\u00fameros <code>abs()</code> Valor absoluto \u274c <code>round()</code> Redondeo \u274c <code>max()</code> M\u00e1ximo de un iterable \u274c <code>min()</code> M\u00ednimo de un iterable \u274c <code>sum()</code> Suma de un iterable \u274c Generales avanzadas <code>map()</code> Aplica una funci\u00f3n a cada elemento \u274c <code>filter()</code> Filtra elementos \u274c <code>any()</code> True si alg\u00fan elemento es verdadero \u274c <code>all()</code> True si todos son verdaderos \u274c"}]}